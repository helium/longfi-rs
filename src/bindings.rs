/* automatically generated by rust-bindgen 0.55.1 */

pub type size_t = ::std::os::raw::c_ulong;
extern "C" {
    #[doc = " Computes a payload hash of sizes up to 32 bytes."]
    #[doc = ""]
    #[doc = " @param[in]     pay     Payload."]
    #[doc = " @param         pay_len Length of payload in bytes."]
    #[doc = " @param[out]    out     Pointer to resultant hash buffer."]
    #[doc = " @param         out_len Desired length of hash in bytes."]
    #[doc = ""]
    #[doc = " @pre           `out_len <= 32`."]
    pub fn lfc_payload_hash(
        pay: *const u8,
        pay_len: size_t,
        out: *mut u8,
        out_len: size_t,
    ) -> lfc_res;
}
extern "C" {
    #[doc = " Calculates the fingerprint for a monolithic datagram."]
    #[doc = ""]
    #[doc = " @param[in]     key     Private cryptographic key."]
    #[doc = " @param         key_len Length of `key` in bytes."]
    #[doc = " @param         hdr     Packed, golay-decoded, 12 bits of tag and flags."]
    #[doc = " @param         oui     Orginizationally Unique Identifier."]
    #[doc = " @param         did     Device Identifier."]
    #[doc = " @param         seq     Sequence number."]
    #[doc = " @param[in]     pay     Payload bytes."]
    #[doc = " @param         pay_len Payload length in bytes."]
    #[doc = " @param[out]    out     Pointer to resultant 32 bit fingerprint."]
    #[doc = ""]
    #[doc = " @pre           `(hdr & 0b1111_0000_0000_0000) == 0`"]
    pub fn lfc_fingerprint_monolithic(
        key: *const u8,
        key_len: size_t,
        hdr: u16,
        oui: u32,
        did: u32,
        seq: u32,
        pay: *const u8,
        pay_len: size_t,
        out: *mut u32,
    ) -> lfc_res;
}
extern "C" {
    #[doc = " Verifies a datagram with a hash of its payload instead of the"]
    #[doc = " actual payload."]
    #[doc = ""]
    #[doc = " @param         fp_decl      Fingerprint we want to verify."]
    #[doc = " @param[in]     key          Private cryptographic key."]
    #[doc = " @param         key_len      Length of `key` in bytes."]
    #[doc = " @param[in]     pay_hash     Hash of payload, *NOT* the payload itself."]
    #[doc = " @param[in]     pay_hash_len Hash of payload, *NOT* the payload itself."]
    #[doc = " @param         hdr          Packed, golay-decoded, 12 bits of tag and flags."]
    #[doc = " @param         oui          Orginizationally Unique Identifier."]
    #[doc = " @param         did          Device Identifier."]
    #[doc = " @param         seq          Sequence number."]
    #[doc = ""]
    #[doc = " @pre           `(hdr & 0b1111_0000_0000_0000) == 0`"]
    pub fn lfc_fingerprint_monolithic_verify(
        fp_decl: u32,
        key: *const u8,
        key_len: size_t,
        pay_hash: *const u8,
        pay_hash_len: size_t,
        hdr: u16,
        oui: u32,
        did: u32,
        seq: u32,
    ) -> lfc_res;
}
#[doc = " Success, no error."]
pub const lfc_res_lfc_res_ok: lfc_res = 0;
#[doc = " Received datagram does not match configured OUI or DID."]
pub const lfc_res_lfc_res_err_addr: lfc_res = 1;
#[doc = " Received datagram's fingerprint does not match locally"]
#[doc = " computed fingerprint."]
pub const lfc_res_lfc_res_err_fingerprint: lfc_res = 2;
#[doc = " Generic, exceptional error."]
pub const lfc_res_lfc_res_err_exception: lfc_res = 3;
#[doc = " Provided buffer is too small for request."]
pub const lfc_res_lfc_res_err_nomem: lfc_res = 4;
#[doc = " Invalid datagram type."]
pub const lfc_res_lfc_res_invalid_type: lfc_res = 5;
#[doc = " Invalid datagram flags."]
pub const lfc_res_lfc_res_invalid_flags: lfc_res = 6;
#[doc = " Return codes for top-level API calls."]
pub type lfc_res = i32;
#[doc = " LongFi user configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lfc_user_cfg {
    #[doc = " Data provided by user, and included with every callback."]
    pub cb_data: *mut ::std::os::raw::c_void,
    #[doc = " Organizational Unique Identifier."]
    pub oui: u32,
    #[doc = " Device ID."]
    pub did: u32,
    #[doc = " Session key."]
    pub key: *const ::std::os::raw::c_void,
    #[doc = " Size (in bytes) of session key."]
    pub key_len: size_t,
}
#[test]
fn bindgen_test_layout_lfc_user_cfg() {
    assert_eq!(
        ::std::mem::size_of::<lfc_user_cfg>(),
        32usize,
        concat!("Size of: ", stringify!(lfc_user_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<lfc_user_cfg>(),
        8usize,
        concat!("Alignment of ", stringify!(lfc_user_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lfc_user_cfg>())).cb_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lfc_user_cfg),
            "::",
            stringify!(cb_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lfc_user_cfg>())).oui as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lfc_user_cfg),
            "::",
            stringify!(oui)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lfc_user_cfg>())).did as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lfc_user_cfg),
            "::",
            stringify!(did)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lfc_user_cfg>())).key as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lfc_user_cfg),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lfc_user_cfg>())).key_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lfc_user_cfg),
            "::",
            stringify!(key_len)
        )
    );
}
#[doc = " LongFi context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lfc {
    #[doc = " Monotonically increasing number included in datagrams."]
    pub seq: u32,
    #[doc = " User-provided configuration."]
    pub cfg: lfc_user_cfg,
}
#[test]
fn bindgen_test_layout_lfc() {
    assert_eq!(
        ::std::mem::size_of::<lfc>(),
        40usize,
        concat!("Size of: ", stringify!(lfc))
    );
    assert_eq!(
        ::std::mem::align_of::<lfc>(),
        8usize,
        concat!("Alignment of ", stringify!(lfc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lfc>())).seq as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(lfc), "::", stringify!(seq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lfc>())).cfg as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(lfc), "::", stringify!(cfg))
    );
}
#[doc = " Represents this library's version."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lfc_version {
    #[doc = " Indicates braking changes when incremented."]
    pub major: u8,
    #[doc = " Indicates added functionality when incremented."]
    pub minor: u8,
    #[doc = " Indicates bug fixes when incremented."]
    pub patch: u8,
}
#[test]
fn bindgen_test_layout_lfc_version() {
    assert_eq!(
        ::std::mem::size_of::<lfc_version>(),
        3usize,
        concat!("Size of: ", stringify!(lfc_version))
    );
    assert_eq!(
        ::std::mem::align_of::<lfc_version>(),
        1usize,
        concat!("Alignment of ", stringify!(lfc_version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lfc_version>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lfc_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lfc_version>())).minor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lfc_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lfc_version>())).patch as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lfc_version),
            "::",
            stringify!(patch)
        )
    );
}
extern "C" {
    #[doc = " Returns `longfi-core`'s version number."]
    pub fn lfc_version() -> lfc_version;
}
extern "C" {
    #[doc = " Initializes a user-provided `lfc` object."]
    #[doc = ""]
    #[doc = " @param lfc               LongFi Context."]
    #[doc = " @param cfg               User-provided configuration."]
    pub fn lfc_init(lfc: *mut lfc, cfg: lfc_user_cfg);
}
extern "C" {
    #[doc = " Decodes a datagram from `in` buffer."]
    #[doc = ""]
    #[doc = " @param lfc               LongFi Context."]
    #[doc = " @param[in] in            Buffer containing an encoded datagram."]
    #[doc = " @param in_len            Length of `in`."]
    #[doc = " @param[out] out          Buffer to write decoded payload to."]
    #[doc = " @param[in,out] out_len    in: capacity of `out` buffer.\\n"]
    #[doc = "                          out: actual size of payload."]
    pub fn lfc_receive(
        lfc: *const lfc,
        in_: *const u8,
        in_len: size_t,
        out: *mut u8,
        out_len: *mut size_t,
    ) -> lfc_res;
}
extern "C" {
    #[doc = " Creates and encodes a datagram into the provided `out` buffer from"]
    #[doc = " `pay`."]
    #[doc = ""]
    #[doc = " @param lfc               LongFi Context."]
    #[doc = " @param pay               Payload you want to send."]
    #[doc = " @param pay_len           Length of `pay`."]
    #[doc = " @param out               Buffer to serialize datagram into."]
    #[doc = " @param[in,out] out_len    in: capacity of `out` buffer.\\n"]
    #[doc = "                          out: actual serialized size of datagram."]
    pub fn lfc_transmit(
        lfc: *mut lfc,
        pay: *const u8,
        pay_len: size_t,
        out: *mut u8,
        out_len: *mut size_t,
    ) -> lfc_res;
}
